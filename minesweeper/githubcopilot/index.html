<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/babel">
      const { useState, useEffect } = React;

      const GRID_SIZE = 9;
      const MINE_COUNT = 76;
      const SAFE_COUNT = GRID_SIZE * GRID_SIZE - MINE_COUNT; // 5å€‹

      function App() {
        const [board, setBoard] = useState([]);
        const [gameStatus, setGameStatus] = useState('playing');
        const [flagCount, setFlagCount] = useState(0);
        const [revealedSafeCells, setRevealedSafeCells] = useState(0);

        // ã‚²ãƒ¼ãƒ åˆæœŸåŒ–
        const initializeGame = () => {
          const newBoard = Array(GRID_SIZE).fill(null).map(() =>
            Array(GRID_SIZE).fill(null).map(() => ({
              isMine: false,
              isRevealed: false,
              isFlagged: false,
              neighborMines: 0,
            }))
          );

          // çˆ†å¼¾ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
          let minesPlaced = 0;
          while (minesPlaced < MINE_COUNT) {
            const row = Math.floor(Math.random() * GRID_SIZE);
            const col = Math.floor(Math.random() * GRID_SIZE);
            if (!newBoard[row][col].isMine) {
              newBoard[row][col].isMine = true;
              minesPlaced++;
            }
          }

          // å„ã‚»ãƒ«ã®å‘¨å›²ã®çˆ†å¼¾æ•°ã‚’è¨ˆç®—
          for (let row = 0; row < GRID_SIZE; row++) {
            for (let col = 0; col < GRID_SIZE; col++) {
              if (!newBoard[row][col].isMine) {
                let count = 0;
                for (let dr = -1; dr <= 1; dr++) {
                  for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (
                      newRow >= 0 && newRow < GRID_SIZE &&
                      newCol >= 0 && newCol < GRID_SIZE &&
                      newBoard[newRow][newCol].isMine
                    ) {
                      count++;
                    }
                  }
                }
                newBoard[row][col].neighborMines = count;
              }
            }
          }

          setBoard(newBoard);
          setGameStatus('playing');
          setFlagCount(0);
          setRevealedSafeCells(0);
        };

        useEffect(() => {
          initializeGame();
        }, []);

        // ã‚»ãƒ«ã‚’é–‹ã(å†å¸°çš„ã«ç©ºç™½ã‚»ãƒ«ã‚’é–‹ã)
        const revealCell = (row, col, currentBoard) => {
          const workBoard = currentBoard || JSON.parse(JSON.stringify(board));

          if (
            row < 0 || row >= GRID_SIZE ||
            col < 0 || col >= GRID_SIZE ||
            workBoard[row][col].isRevealed ||
            workBoard[row][col].isFlagged
          ) {
            return { board: workBoard, revealed: 0 };
          }

          workBoard[row][col].isRevealed = true;
          let revealedCount = workBoard[row][col].isMine ? 0 : 1;

          // å‘¨å›²ã«çˆ†å¼¾ãŒãªã„å ´åˆã€å‘¨å›²ã®ã‚»ãƒ«ã‚‚é–‹ã
          if (!workBoard[row][col].isMine && workBoard[row][col].neighborMines === 0) {
            for (let dr = -1; dr <= 1; dr++) {
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const result = revealCell(row + dr, col + dc, workBoard);
                workBoard = result.board;
                revealedCount += result.revealed;
              }
            }
          }

          return { board: workBoard, revealed: revealedCount };
        };

        // ã‚»ãƒ«ã‚¯ãƒªãƒƒã‚¯
        const handleCellClick = (row, col) => {
          if (gameStatus !== 'playing' || board[row][col].isFlagged || board[row][col].isRevealed) {
            return;
          }

          if (board[row][col].isMine) {
            // çˆ†å¼¾ã‚’è¸ã‚“ã  - ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
            const newBoard = board.map(row => row.map(cell => ({ ...cell, isRevealed: true })));
            setBoard(newBoard);
            setGameStatus('lost');
          } else {
            // ã‚»ãƒ«ã‚’é–‹ã
            const result = revealCell(row, col);
            setBoard(result.board);
            const newRevealedCount = revealedSafeCells + result.revealed;
            setRevealedSafeCells(newRevealedCount);

            // å‹åˆ©åˆ¤å®š
            if (newRevealedCount === SAFE_COUNT) {
              setGameStatus('won');
            }
          }
        };

        // å³ã‚¯ãƒªãƒƒã‚¯(ãƒ•ãƒ©ã‚°è¨­ç½®)
        const handleCellRightClick = (e, row, col) => {
          e.preventDefault();
          if (gameStatus !== 'playing' || board[row][col].isRevealed) {
            return;
          }

          const newBoard = [...board];
          newBoard[row][col].isFlagged = !newBoard[row][col].isFlagged;
          setBoard(newBoard);
          setFlagCount(newBoard[row][col].isFlagged ? flagCount + 1 : flagCount - 1);
        };

        // ã‚»ãƒ«ã®è¡¨ç¤ºå†…å®¹ã‚’æ±ºå®š
        const getCellContent = (cell) => {
          if (cell.isFlagged && !cell.isRevealed) {
            return 'ğŸš©';
          }
          if (!cell.isRevealed) {
            return '';
          }
          if (cell.isMine) {
            return 'ğŸ’£';
          }
          if (cell.neighborMines === 0) {
            return '';
          }
          return cell.neighborMines;
        };

        // ã‚»ãƒ«ã®è‰²ã‚’æ±ºå®š
        const getCellColor = (cell) => {
          if (!cell.isRevealed) {
            return 'bg-gray-400 hover:bg-gray-300';
          }
          if (cell.isMine) {
            return 'bg-red-500';
          }
          return 'bg-gray-100';
        };

        // æ•°å­—ã®è‰²
        const getNumberColor = (num) => {
          const colors = {
            1: 'text-blue-600',
            2: 'text-green-600',
            3: 'text-red-600',
            4: 'text-purple-600',
            5: 'text-orange-600',
            6: 'text-cyan-600',
            7: 'text-black',
            8: 'text-gray-600',
          };
          return colors[num] || 'text-black';
        };

        return (
          <div className="container mx-auto p-8 max-w-4xl">
            <h1 className="text-4xl font-bold mb-6 text-center text-gray-800">
              ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼ ğŸ’£
            </h1>

            <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
              <div className="flex justify-between items-center mb-4">
                <div className="text-lg font-semibold">
                  <span className="text-gray-700">çˆ†å¼¾: </span>
                  <span className="text-red-600">{MINE_COUNT}</span>
                </div>
                <div className="text-lg font-semibold">
                  <span className="text-gray-700">ãƒ•ãƒ©ã‚°: </span>
                  <span className="text-blue-600">{flagCount}</span>
                </div>
                <div className="text-lg font-semibold">
                  <span className="text-gray-700">å®‰å…¨åœ°å¸¯ç™ºè¦‹: </span>
                  <span className="text-green-600">{revealedSafeCells} / {SAFE_COUNT}</span>
                </div>
              </div>

              {gameStatus === 'won' && (
                <div className="bg-green-100 border-2 border-green-500 rounded-lg p-4 mb-4 text-center">
                  <p className="text-2xl font-bold text-green-700">ğŸ‰ ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼ ğŸ‰</p>
                </div>
              )}

              {gameStatus === 'lost' && (
                <div className="bg-red-100 border-2 border-red-500 rounded-lg p-4 mb-4 text-center">
                  <p className="text-2xl font-bold text-red-700">ğŸ’¥ ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼ ğŸ’¥</p>
                </div>
              )}

              <div className="flex justify-center mb-4">
                <button
                  onClick={initializeGame}
                  className="px-6 py-3 bg-blue-500 text-white rounded-lg hover:bg-blue-600 font-semibold text-lg shadow-md transition-colors"
                >
                  æ–°ã—ã„ã‚²ãƒ¼ãƒ 
                </button>
              </div>

              <div className="flex flex-col items-center">
                <div className="inline-block border-4 border-gray-600 rounded-lg overflow-hidden">
                  {board.map((row, rowIndex) => (
                    <div key={rowIndex} className="flex">
                      {row.map((cell, colIndex) => (
                        <button
                          key={`${rowIndex}-${colIndex}`}
                          onClick={() => handleCellClick(rowIndex, colIndex)}
                          onContextMenu={(e) => handleCellRightClick(e, rowIndex, colIndex)}
                          className={`w-10 h-10 border border-gray-300 flex items-center justify-center font-bold text-sm transition-colors ${getCellColor(cell)} ${
                            cell.isRevealed && !cell.isMine && cell.neighborMines > 0
                              ? getNumberColor(cell.neighborMines)
                              : ''
                          }`}
                          disabled={gameStatus !== 'playing' && !cell.isRevealed}
                        >
                          {getCellContent(cell)}
                        </button>
                      ))}
                    </div>
                  ))}
                </div>
              </div>

              <div className="mt-4 text-sm text-gray-600 text-center">
                <p>ğŸ’¡ å·¦ã‚¯ãƒªãƒƒã‚¯: ã‚»ãƒ«ã‚’é–‹ã | å³ã‚¯ãƒªãƒƒã‚¯: ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹</p>
                <p className="mt-1">ğŸ¯ ç›®æ¨™: çˆ†å¼¾ã‚’é¿ã‘ã¦å®‰å…¨ãª5å€‹ã®ã‚»ãƒ«ã‚’å…¨ã¦è¦‹ã¤ã‘ã‚‹ï¼</p>
              </div>
            </div>
          </div>
        );
      }

      const rootEl = document.getElementById("root");
      ReactDOM.render(<App />, rootEl);
    </script>
  </body>
</html>
