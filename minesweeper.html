<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@19",
          "react-dom/client": "https://esm.sh/react-dom@19/client"
        }
      }
    </script>
    <script type="module" src="https://esm.sh/tsx"></script>
  </head>
  <body>
    <div id="root"></div>

    <script type="text/tsx">
      import React, { useState, useEffect } from "react";
      import { createRoot } from "react-dom/client";

      const GRID_SIZE = 9;
      const MINE_COUNT = 76;
      const SAFE_ZONES = GRID_SIZE * GRID_SIZE - MINE_COUNT; // 5å€‹

      type Cell = {
        isMine: boolean;
        isRevealed: boolean;
        isFlagged: boolean;
        neighborMines: number;
      };

      type GameStatus = 'playing' | 'won' | 'lost';

      function App() {
        const [board, setBoard] = useState<Cell[][]>([]);
        const [gameStatus, setGameStatus] = useState<GameStatus>('playing');
        const [flagCount, setFlagCount] = useState(0);
        const [revealedCount, setRevealedCount] = useState(0);

        // ãƒœãƒ¼ãƒ‰ã®åˆæœŸåŒ–
        const initializeBoard = () => {
          // ç©ºã®ãƒœãƒ¼ãƒ‰ã‚’ä½œæˆ
          const newBoard: Cell[][] = Array(GRID_SIZE).fill(null).map(() =>
            Array(GRID_SIZE).fill(null).map(() => ({
              isMine: false,
              isRevealed: false,
              isFlagged: false,
              neighborMines: 0,
            }))
          );

          // åœ°é›·ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é…ç½®
          const positions: number[] = [];
          for (let i = 0; i < GRID_SIZE * GRID_SIZE; i++) {
            positions.push(i);
          }

          // Fisher-Yatesã‚·ãƒ£ãƒƒãƒ•ãƒ«
          for (let i = positions.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1));
            [positions[i], positions[j]] = [positions[j], positions[i]];
          }

          // æœ€åˆã®MINE_COUNTå€‹ã‚’åœ°é›·ã«
          for (let i = 0; i < MINE_COUNT; i++) {
            const pos = positions[i];
            const row = Math.floor(pos / GRID_SIZE);
            const col = pos % GRID_SIZE;
            newBoard[row][col].isMine = true;
          }

          // å‘¨å›²ã®åœ°é›·æ•°ã‚’è¨ˆç®—
          for (let row = 0; row < GRID_SIZE; row++) {
            for (let col = 0; col < GRID_SIZE; col++) {
              if (!newBoard[row][col].isMine) {
                let count = 0;
                for (let dr = -1; dr <= 1; dr++) {
                  for (let dc = -1; dc <= 1; dc++) {
                    if (dr === 0 && dc === 0) continue;
                    const newRow = row + dr;
                    const newCol = col + dc;
                    if (
                      newRow >= 0 &&
                      newRow < GRID_SIZE &&
                      newCol >= 0 &&
                      newCol < GRID_SIZE &&
                      newBoard[newRow][newCol].isMine
                    ) {
                      count++;
                    }
                  }
                }
                newBoard[row][col].neighborMines = count;
              }
            }
          }

          setBoard(newBoard);
          setGameStatus('playing');
          setFlagCount(0);
          setRevealedCount(0);
        };

        useEffect(() => {
          initializeBoard();
        }, []);

        // ã‚»ãƒ«ã‚’é–‹ã
        const revealCell = (row: number, col: number) => {
          if (gameStatus !== 'playing') return;
          if (board[row][col].isRevealed || board[row][col].isFlagged) return;

          const newBoard = board.map(row => row.map(cell => ({ ...cell })));

          const reveal = (r: number, c: number) => {
            if (
              r < 0 ||
              r >= GRID_SIZE ||
              c < 0 ||
              c >= GRID_SIZE ||
              newBoard[r][c].isRevealed ||
              newBoard[r][c].isFlagged
            ) {
              return;
            }

            newBoard[r][c].isRevealed = true;

            // åœ°é›·ã‚’è¸ã‚“ã 
            if (newBoard[r][c].isMine) {
              setGameStatus('lost');
              // ã™ã¹ã¦ã®åœ°é›·ã‚’è¡¨ç¤º
              for (let i = 0; i < GRID_SIZE; i++) {
                for (let j = 0; j < GRID_SIZE; j++) {
                  if (newBoard[i][j].isMine) {
                    newBoard[i][j].isRevealed = true;
                  }
                }
              }
              return;
            }

            // å‘¨å›²ã«åœ°é›·ãŒãªã„å ´åˆã€é€£é–çš„ã«é–‹ã
            if (newBoard[r][c].neighborMines === 0) {
              for (let dr = -1; dr <= 1; dr++) {
                for (let dc = -1; dc <= 1; dc++) {
                  if (dr === 0 && dc === 0) continue;
                  reveal(r + dr, c + dc);
                }
              }
            }
          };

          reveal(row, col);
          setBoard(newBoard);

          // å‹åˆ©åˆ¤å®š
          const revealed = newBoard.flat().filter(cell => cell.isRevealed && !cell.isMine).length;
          setRevealedCount(revealed);
          if (revealed === SAFE_ZONES && gameStatus === 'playing') {
            setGameStatus('won');
          }
        };

        // ãƒ•ãƒ©ã‚°ã®åˆ‡ã‚Šæ›¿ãˆ
        const toggleFlag = (row: number, col: number, e: React.MouseEvent) => {
          e.preventDefault();
          if (gameStatus !== 'playing') return;
          if (board[row][col].isRevealed) return;

          const newBoard = board.map(row => row.map(cell => ({ ...cell })));
          newBoard[row][col].isFlagged = !newBoard[row][col].isFlagged;
          setBoard(newBoard);
          setFlagCount(newBoard.flat().filter(cell => cell.isFlagged).length);
        };

        const getCellContent = (cell: Cell) => {
          if (!cell.isRevealed) {
            return cell.isFlagged ? 'ğŸš©' : '';
          }
          if (cell.isMine) {
            return 'ğŸ’£';
          }
          if (cell.neighborMines === 0) {
            return '';
          }
          return cell.neighborMines;
        };

        const getCellColor = (cell: Cell) => {
          if (!cell.isRevealed) {
            return 'bg-gray-400 hover:bg-gray-500';
          }
          if (cell.isMine) {
            return 'bg-red-500';
          }
          return 'bg-gray-200';
        };

        const getNumberColor = (num: number) => {
          const colors: { [key: number]: string } = {
            1: 'text-blue-600',
            2: 'text-green-600',
            3: 'text-red-600',
            4: 'text-purple-600',
            5: 'text-yellow-600',
            6: 'text-pink-600',
            7: 'text-black',
            8: 'text-gray-600',
          };
          return colors[num] || 'text-black';
        };

        return (
          <div className="min-h-screen bg-gradient-to-br from-blue-100 to-purple-100 p-4">
            <div className="container mx-auto max-w-2xl">
              <h1 className="text-4xl font-bold text-center mb-6 text-gray-800">
                ãƒã‚¤ãƒ³ã‚¹ã‚¤ãƒ¼ãƒ‘ãƒ¼
              </h1>

              {/* ã‚²ãƒ¼ãƒ æƒ…å ± */}
              <div className="bg-white rounded-lg shadow-lg p-4 mb-4">
                <div className="flex justify-between items-center">
                  <div className="text-lg">
                    <span className="font-semibold">åœ°é›·:</span> {MINE_COUNT}å€‹
                  </div>
                  <div className="text-lg">
                    <span className="font-semibold">ãƒ•ãƒ©ã‚°:</span> {flagCount}
                  </div>
                  <div className="text-lg">
                    <span className="font-semibold">å®‰å…¨åœ°å¸¯:</span> {revealedCount}/{SAFE_ZONES}
                  </div>
                </div>

                {/* ã‚²ãƒ¼ãƒ ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ */}
                {gameStatus === 'won' && (
                  <div className="mt-4 p-3 bg-green-100 border-2 border-green-500 rounded text-center text-xl font-bold text-green-700">
                    ã‚¯ãƒªã‚¢ï¼ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼
                  </div>
                )}
                {gameStatus === 'lost' && (
                  <div className="mt-4 p-3 bg-red-100 border-2 border-red-500 rounded text-center text-xl font-bold text-red-700">
                    ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼
                  </div>
                )}

                <button
                  onClick={initializeBoard}
                  className="w-full mt-4 px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors font-semibold"
                >
                  æ–°ã—ã„ã‚²ãƒ¼ãƒ 
                </button>
              </div>

              {/* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ */}
              <div className="bg-white rounded-lg shadow-lg p-4">
                <div className="grid gap-1" style={{ gridTemplateColumns: `repeat(${GRID_SIZE}, 1fr)` }}>
                  {board.map((row, rowIndex) =>
                    row.map((cell, colIndex) => (
                      <button
                        key={`${rowIndex}-${colIndex}`}
                        onClick={() => revealCell(rowIndex, colIndex)}
                        onContextMenu={(e) => toggleFlag(rowIndex, colIndex, e)}
                        className={`
                          aspect-square flex items-center justify-center
                          text-sm sm:text-base font-bold rounded
                          border-2 border-gray-300
                          transition-all duration-150
                          ${getCellColor(cell)}
                          ${!cell.isRevealed && 'active:scale-95'}
                        `}
                        disabled={gameStatus !== 'playing' && !cell.isRevealed}
                      >
                        <span className={getNumberColor(cell.neighborMines)}>
                          {getCellContent(cell)}
                        </span>
                      </button>
                    ))
                  )}
                </div>
              </div>

              {/* æ“ä½œèª¬æ˜ */}
              <div className="mt-4 bg-white rounded-lg shadow-lg p-4">
                <h2 className="font-bold text-lg mb-2">æ“ä½œæ–¹æ³•</h2>
                <ul className="space-y-1 text-sm text-gray-700">
                  <li>ãƒ»å·¦ã‚¯ãƒªãƒƒã‚¯: ã‚»ãƒ«ã‚’é–‹ã</li>
                  <li>ãƒ»å³ã‚¯ãƒªãƒƒã‚¯: ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹/å¤–ã™</li>
                  <li>ãƒ»ç›®æ¨™: åœ°é›·ä»¥å¤–ã®5ã¤ã®å®‰å…¨åœ°å¸¯ã‚’ã™ã¹ã¦è¦‹ã¤ã‘ã‚‹</li>
                  <li>ãƒ»æ•°å­—: å‘¨å›²8ãƒã‚¹ã«ã‚ã‚‹åœ°é›·ã®æ•°</li>
                </ul>
              </div>
            </div>
          </div>
        );
      }

      const rootEl = document.getElementById("root");
      createRoot(rootEl).render(<App />);
    </script>
  </body>
</html>
